##
# This file is part of the 'I Vote Goat' project.
#
# Copyright (C) 2014 Stefan Wendler <sw@kaltpost.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
##

__author__ = 'Stefan Wendler, sw@kaltpost.de'

import requests as req
from xml.dom.minidom import getDOMImplementation
from xml.dom.minidom import parseString

import logging as log
import dataevent as di


class SmartPlug(object):

    """
    Simple class to access a "EDIMAX Smart Plug Switch SP-1101W"

    Usage example when used as library:

    p = SmartPlug("172.16.100.75", ('admin', '1234'))

    p.state = "OFF"
    p.state = "ON"
    print(p.state)

    Usage example when used as command line utility:

    turn plug on:

    python smartplug.py -H 172.16.100.75 -l admin -p 1234 -s ON

    turn plug off:

    python smartplug.py -H 172.16.100.75-l admin -p 1234 -s OFF

    get plug state:

    python smartplug.py -H 172.16.100.75-l admin -p 1234 -g

    """

    def __init__(self, host, auth):

        """
        Create a new SmartPlug instance identified by the given URL.

        :rtype : object
        :param host: The IP/hostname of the SmartPlug. E.g. '172.16.100.75'
        :param auth: User and password to authenticate with the plug. E.g. ('admin', '1234')
        """

        self.url = "http://%s:10000/smartplug.cgi" % host
        self.auth = auth
        self.domi = getDOMImplementation()

    def __xml_cmd(self, cmdId, cmdStr):

        """
        Create XML representation of a command.

        :param cmdId: Use 'get' to request plug state, use 'setup' change plug state.
        :param cmdStr: Empty string for 'get', 'ON' or 'OFF' for 'setup'
        :return: XML representation of command
        """

        doc = self.domi.createDocument(None, "SMARTPLUG", None)
        doc.documentElement.setAttribute("id", "edimax")

        cmd = doc.createElement("CMD")
        cmd.setAttribute("id", cmdId)
        state = doc.createElement("Device.System.Power.State")
        cmd.appendChild(state)
        state.appendChild(doc.createTextNode(cmdStr))

        doc.documentElement.appendChild(cmd)

        return doc.toxml()

    def __post_xml(self, xml):

        """
        Post XML command  as multipart file to SmartPlug, parse XML response.

        :param xml: XML representation of command (as generated by __xml_cmd)
        :return: 'OK' on success, 'FAILED' otherwise
        """

        files = {'file': xml}

        res = req.post(self.url, auth=self.auth, files=files)

        if res.status_code == req.codes.ok:
            dom = parseString(res.text)

            try:
                val = dom.getElementsByTagName("CMD")[0].firstChild.nodeValue

                if val is None:
                    val = dom.getElementsByTagName("CMD")[0].getElementsByTagName("Device.System.Power.State")[0].\
                        firstChild.nodeValue

                return val

            except Exception as e:

                print(e.__str__())

        return None

    @property
    def state(self):

        """
        Get the current state of the SmartPlug.

        :return: 'ON' or 'OFF'
        """

        res = self.__post_xml(self.__xml_cmd("get", ""))

        if res != "ON" and res != "OFF":
            raise Exception("Failed to communicate with SmartPlug")

        return res

    @state.setter
    def state(self, value):

        """
        Set the state of the SmartPlug

        :param value: 'ON', 'on', 'OFF' or 'off'
        """

        if value == "ON" or value == "on":
            res = self.__post_xml(self.__xml_cmd("setup", "ON"))
        else:
            res = self.__post_xml(self.__xml_cmd("setup", "OFF"))

        if res != "OK":
            raise Exception("Failed to communicate with SmartPlug")


class Plugin(di.DataEvent):

    def __init__(self):

        di.DataEvent.__init__(self, "SmartPlug")

        # self.dp.set_plugconf(self.name, "host", "172.16.100.75")
        # self.dp.set_plugconf(self.name, "login", "admin")
        # self.dp.set_plugconf(self.name, "password", "1234")
        # self.dp.set_plugconf(self.name, "users", "aime:annie")

        self.host = self.dp.get_plugconf(self.name, "host")

        if self.host is None:
            raise Exception("%s: host not configured" % self.name)

        self.login = self.dp.get_plugconf(self.name, "login")

        if self.login is None:
            raise Exception("%s: login not configured" % self.name)

        self.password = self.dp.get_plugconf(self.name, "password")

        if self.password is None:
            raise Exception("%s: password not configured" % self.name)

        self.sp = SmartPlug(self.host, (self.login, self.password))
        self.init_for_users()

    def init_for_users(self):

        users = self.dp.get_plugconf(self.name, "users").split(":")

        state = "ON"

        for user in users:
            if self.dp.count_points(user) > 0:
                state = "OFF"
                break

        log.info("[%s] state for %s is set to %s" % (self.name, self.host, state))

        self.sp.state = state

    def applies_to_user(self, nickname):

        users = self.dp.get_plugconf(self.name, "users").split(":")

        for user in users:
            if user == nickname:
                return True

        return False

    def add_point(self, nickname, points_left):

        log.info("[%s] user point added: %s (%d)" % (self.name, nickname, points_left))

        if not self.applies_to_user(nickname):
            return

        try:
            log.info("[%s] turning %s OFF for user: %s" % (self.name, self.host, nickname))
            self.sp.state = "OFF"
        except Exception as e:
            log.error(e.__str__())

    def del_point(self, nickname, points_left):
        log.info("[%s] user point deleted: %s (%d)" % (self.name, nickname, points_left))

        if not self.applies_to_user(nickname):
            return

        if points_left == 0:
            try:
                self.init_for_users()
            except Exception as e:
                log.error(e.__str__())
